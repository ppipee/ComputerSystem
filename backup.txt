
insertionSortRecursive:
    # push $ra and old $fp on to the stack
	addiu $sp, $sp, -8
	sw $ra, 4($sp)
	sw $fp, 0($sp)
	addu $fp, $zero, $sp # set $fp to top of stack

    addiu $sp, $sp, -8 # allocate memory for "last" and "j"    
    
    lw $s0, 56($fp) # load parameter N
    # if n>1 go to after_base_case
    slti $s1, $s0, 1
    beqz $s1, after_base_case
    # base case
    # return
        addiu $sp, $sp, 8 # adjust stack pointer
        # restore the return address 
        lw $ra, 4($sp)
        lw $fp, 0($sp)
        # deallocate the stack memory 
        addi $sp, $sp, 8
        # jump to address of $ra 
        jr $ra
    after_base_case:

    addi $s1, $s0, -1 # n-=1
    addiu $sp, $sp, -4
    sw $s1, 0($sp) # send argument n-1 to stack
    
    addiu $sp, $sp, -48 # allocate memory for arr data
    # loop receive array of parameter and send array data to present stack
    li $s2, 0 # i=0
    send_address:
        beq $s2, $s0, end_send_add # if n>=12 end loop
        sll $s3, $s2, 2 # i*=4 
        addu $s4, $s3, $fp # get address arr[i*4]
         
        addu $s5, $s3, $sp # calculate address for send to stack
        sw $s4, 0($s5) # store address 
        addi $s2, $s2, 1 # i++

        j send_address
    end_send_add:

    # store $s1 (n-1) on stack
    addiu $sp, $sp, -4
    sw $s1, 0($sp)
    
    jal insertionSortRecursive # recursive

    # load $s1 (n-1) from stack
    lw $s1, 0($sp)
    addiu $sp, $sp, 4

    li $v0, 1
    move $a0, $s1
    syscall

    addiu $sp, $sp, 52 # adjust stack pointer

    addiu $s3, $fp, 8 # fp + 8

    # load address arr[n-1]
    sll $s2, $s1, 2 
    addu $s2, $s2, $s3
    lw $s2, 0($s2) # load address of arr[n-1]
#    lw $s2, 0($s2) # load array data from address arr[n-1] (last = arr[n-])
    addi $s1, $s0, -2 # j = n-2

    while:
        # load arr[j] 
        sll $s4, $s1, 2
        addu $s4, $s4, $s3 
        lw $s4, 0($s4) # load address of arr[j]
 #       lw $s4, 0($s4) # load data of arr[j]
        slt $s5, $s2, $s4 # last < add[j] 

        slti $s6, $s1,0 # j<0
        not $s6, $s6 # j >=0
        and $s5, $s5, $s6
        beqz $s5, end_while

        # load address arr[j+1]
        addiu $s7, $s1, 1 # j+1
        sll $s7, $s7, 2
        addu $s7, $s7, $s3 # j + 1 + fp + 8 
        lw $s7, 0($s7) # load address of arr[j+1]
        
        sw $s4, 0($s7) # arr[j+1] = arr[j]

        addi $s1, $s1, -1
        j while
    end_while:

        # load address of arr[j+1]
        addiu $s7, $s1, 1
        sll $s7, $s7, 2
        addu $s7, $s7, $s3 # j + 1 + fp + 8 
        lw $s7, 0($s7) # load address of arr[j+1]

        sw $s2, 0($s7) # arr[j+1] = last 

    # return
    addiu $sp, $sp, 8 # adjust stack pointer
    # restore the return address 
    lw $ra, 4($sp)
    lw $fp, 0($sp)
    # deallocate the stack memory 
    addi $sp, $sp, 8
    # jump to address of $ra 
    jr $ra
